#pragma once 
#include <Register/Utility.hpp>
namespace Kvasir {
//CRS
    namespace CrsCrsCr{    ///<CRS control register
        using Addr = Register::Address<0x40008400,0xffffc010,0x00000000,std::uint32_t>;
        ///SYNC event OK interrupt              enable
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(0,0),Register::ReadWriteAccess,unsigned> syncokie{}; 
        ///SYNC warning interrupt              enable
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(1,1),Register::ReadWriteAccess,unsigned> syncwarnie{}; 
        ///Synchronization or trimming error              interrupt enable
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(2,2),Register::ReadWriteAccess,unsigned> errie{}; 
        ///Expected SYNC interrupt              enable
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(3,3),Register::ReadWriteAccess,unsigned> esyncie{}; 
        ///Frequency error counter enable This bit              enables the oscillator clock for the frequency error              counter. When this bit is set, the CRS_CFGR register              is write-protected and cannot be              modified.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(5,5),Register::ReadWriteAccess,unsigned> cen{}; 
        ///Automatic trimming enable This bit              enables the automatic hardware adjustment of TRIM              bits according to the measured frequency error              between two SYNC events. If this bit is set, the TRIM              bits are read-only. The TRIM value can be adjusted by              hardware by one or two steps at a time, depending on              the measured frequency error value. Refer to              Section7.3.4: Frequency error evaluation and              automatic trimming for more details.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(6,6),Register::ReadWriteAccess,unsigned> autotrimen{}; 
        ///Generate software SYNC event This bit is              set by software in order to generate a software SYNC              event. It is automatically cleared by              hardware.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(7,7),Register::Access<Register::AccessType::readOnly,Register::ReadActionType::normal,Register::ModifiedWriteValueType::normal>,unsigned> swsync{}; 
        ///HSI48 oscillator smooth trimming These              bits provide a user-programmable trimming value to              the HSI48 oscillator. They can be programmed to              adjust to variations in voltage and temperature that              influence the frequency of the HSI48. The default              value is 32, which corresponds to the middle of the              trimming interval. The trimming step is around 67 kHz              between two consecutive TRIM steps. A higher TRIM              value corresponds to a higher output frequency. When              the AUTOTRIMEN bit is set, this field is controlled              by hardware and is read-only.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(13,8),Register::ReadWriteAccess,unsigned> trim{}; 
    }
    namespace CrsCrsCfgr{    ///<This register can be written only when the          frequency error counter is disabled (CEN bit is cleared          in CRS_CR). When the counter is enabled, this register is          write-protected.
        using Addr = Register::Address<0x40008404,0x48000000,0x00000000,std::uint32_t>;
        ///Counter reload value RELOAD is the value              to be loaded in the frequency error counter with each              SYNC event. Refer to Section7.3.3: Frequency error              measurement for more details about counter              behavior.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(15,0),Register::ReadWriteAccess,unsigned> reload{}; 
        ///Frequency error limit FELIM contains the              value to be used to evaluate the captured frequency              error value latched in the FECAP[15:0] bits of the              CRS_ISR register. Refer to Section7.3.4: Frequency              error evaluation and automatic trimming for more              details about FECAP evaluation.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(23,16),Register::ReadWriteAccess,unsigned> felim{}; 
        ///SYNC divider These bits are set and              cleared by software to control the division factor of              the SYNC signal.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(26,24),Register::ReadWriteAccess,unsigned> syncdiv{}; 
        ///SYNC signal source selection These bits              are set and cleared by software to select the SYNC              signal source. Note: When using USB LPM (Link Power              Management) and the device is in Sleep mode, the              periodic USB SOF will not be generated by the host.              No SYNC signal will therefore be provided to the CRS              to calibrate the HSI48 on the run. To guarantee the              required clock precision after waking up from Sleep              mode, the LSE or reference clock on the GPIOs should              be used as SYNC signal.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(29,28),Register::ReadWriteAccess,unsigned> syncsrc{}; 
        ///SYNC polarity selection This bit is set              and cleared by software to select the input polarity              for the SYNC signal source.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(31,31),Register::ReadWriteAccess,unsigned> syncpol{}; 
    }
    namespace CrsCrsIsr{    ///<CRS interrupt and status          register
        using Addr = Register::Address<0x40008408,0x000078f0,0x00000000,std::uint32_t>;
        ///SYNC event OK flag This flag is set by              hardware when the measured frequency error is smaller              than FELIM * 3. This means that either no adjustment              of the TRIM value is needed or that an adjustment by              one trimming step is enough to compensate the              frequency error. An interrupt is generated if the              SYNCOKIE bit is set in the CRS_CR register. It is              cleared by software by setting the SYNCOKC bit in the              CRS_ICR register.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(0,0),Register::ReadWriteAccess,unsigned> syncokf{}; 
        ///SYNC warning flag This flag is set by              hardware when the measured frequency error is greater              than or equal to FELIM * 3, but smaller than FELIM *              128. This means that to compensate the frequency              error, the TRIM value must be adjusted by two steps              or more. An interrupt is generated if the SYNCWARNIE              bit is set in the CRS_CR register. It is cleared by              software by setting the SYNCWARNC bit in the CRS_ICR              register.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(1,1),Register::ReadWriteAccess,unsigned> syncwarnf{}; 
        ///Error flag This flag is set by hardware              in case of any synchronization or trimming error. It              is the logical OR of the TRIMOVF, SYNCMISS and              SYNCERR bits. An interrupt is generated if the ERRIE              bit is set in the CRS_CR register. It is cleared by              software in reaction to setting the ERRC bit in the              CRS_ICR register, which clears the TRIMOVF, SYNCMISS              and SYNCERR bits.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(2,2),Register::ReadWriteAccess,unsigned> errf{}; 
        ///Expected SYNC flag This flag is set by              hardware when the frequency error counter reached a              zero value. An interrupt is generated if the ESYNCIE              bit is set in the CRS_CR register. It is cleared by              software by setting the ESYNCC bit in the CRS_ICR              register.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(3,3),Register::ReadWriteAccess,unsigned> esyncf{}; 
        ///SYNC error This flag is set by hardware              when the SYNC pulse arrives before the ESYNC event              and the measured frequency error is greater than or              equal to FELIM * 128. This means that the frequency              error is too big (internal frequency too low) to be              compensated by adjusting the TRIM value, and that              some other action should be taken. An interrupt is              generated if the ERRIE bit is set in the CRS_CR              register. It is cleared by software by setting the              ERRC bit in the CRS_ICR register.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(8,8),Register::ReadWriteAccess,unsigned> syncerr{}; 
        ///SYNC missed This flag is set by hardware              when the frequency error counter reached value FELIM              * 128 and no SYNC was detected, meaning either that a              SYNC pulse was missed or that the frequency error is              too big (internal frequency too high) to be              compensated by adjusting the TRIM value, and that              some other action should be taken. At this point, the              frequency error counter is stopped (waiting for a              next SYNC) and an interrupt is generated if the ERRIE              bit is set in the CRS_CR register. It is cleared by              software by setting the ERRC bit in the CRS_ICR              register.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(9,9),Register::ReadWriteAccess,unsigned> syncmiss{}; 
        ///Trimming overflow or underflow This flag              is set by hardware when the automatic trimming tries              to over- or under-flow the TRIM value. An interrupt              is generated if the ERRIE bit is set in the CRS_CR              register. It is cleared by software by setting the              ERRC bit in the CRS_ICR register.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(10,10),Register::ReadWriteAccess,unsigned> trimovf{}; 
        ///Frequency error direction FEDIR is the              counting direction of the frequency error counter              latched in the time of the last SYNC event. It shows              whether the actual frequency is below or above the              target.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(15,15),Register::ReadWriteAccess,unsigned> fedir{}; 
        ///Frequency error capture FECAP is the              frequency error counter value latched in the time of              the last SYNC event. Refer to Section7.3.4: Frequency              error evaluation and automatic trimming for more              details about FECAP usage.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(31,16),Register::ReadWriteAccess,unsigned> fecap{}; 
    }
    namespace CrsCrsIcr{    ///<CRS interrupt flag clear          register
        using Addr = Register::Address<0x4000840c,0xfffffff0,0x00000000,std::uint32_t>;
        ///SYNC event OK clear flag Writing 1 to              this bit clears the SYNCOKF flag in the CRS_ISR              register.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(0,0),Register::ReadWriteAccess,unsigned> syncokc{}; 
        ///SYNC warning clear flag Writing 1 to              this bit clears the SYNCWARNF flag in the CRS_ISR              register.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(1,1),Register::ReadWriteAccess,unsigned> syncwarnc{}; 
        ///Error clear flag Writing 1 to this bit              clears TRIMOVF, SYNCMISS and SYNCERR bits and              consequently also the ERRF flag in the CRS_ISR              register.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(2,2),Register::ReadWriteAccess,unsigned> errc{}; 
        ///Expected SYNC clear flag Writing 1 to              this bit clears the ESYNCF flag in the CRS_ISR              register.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(3,3),Register::ReadWriteAccess,unsigned> esyncc{}; 
    }
}
