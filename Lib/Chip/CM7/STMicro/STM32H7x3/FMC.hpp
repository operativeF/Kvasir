#pragma once 
#include <Register/Utility.hpp>
namespace Kvasir {
//FMC
    namespace FmcFmcBcr1{    ///<This register contains the control          information of each memory bank, used for SRAMs, PSRAM          and NOR Flash memories.
        using Addr = Register::Address<0x52004000,0x7cc00480,0x00000000,std::uint32_t>;
        ///Memory bank enable bit This bit enables              the memory bank. After reset Bank1 is enabled, all              others are disabled. Accessing a disabled bank causes              an ERROR on AXI bus.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(0,0),Register::ReadWriteAccess,unsigned> mbken{}; 
        ///Address/data multiplexing enable bit              When this bit is set, the address and data values are              multiplexed on the data bus, valid only with NOR and              PSRAM memories:
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(1,1),Register::ReadWriteAccess,unsigned> muxen{}; 
        ///Memory type These bits define the type              of external memory attached to the corresponding              memory bank:
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(3,2),Register::ReadWriteAccess,unsigned> mtyp{}; 
        ///Memory data bus width Defines the              external memory device width, valid for all type of              memories.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(5,4),Register::ReadWriteAccess,unsigned> mwid{}; 
        ///Flash access enable This bit enables NOR              Flash memory access operations.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(6,6),Register::ReadWriteAccess,unsigned> faccen{}; 
        ///Burst enable bit This bit              enables/disables synchronous accesses during read              operations. It is valid only for synchronous memories              operating in Burst mode:
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(8,8),Register::ReadWriteAccess,unsigned> bursten{}; 
        ///Wait signal polarity bit This bit              defines the polarity of the wait signal from memory              used for either in synchronous or asynchronous              mode:
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(9,9),Register::ReadWriteAccess,unsigned> waitpol{}; 
        ///Wait timing configuration The NWAIT              signal indicates whether the data from the memory are              valid or if a wait state must be inserted when              accessing the memory in synchronous mode. This              configuration bit determines if NWAIT is asserted by              the memory one clock cycle before the wait state or              during the wait state:
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(11,11),Register::ReadWriteAccess,unsigned> waitcfg{}; 
        ///Write enable bit This bit indicates              whether write operations are enabled/disabled in the              bank by the FMC:
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(12,12),Register::ReadWriteAccess,unsigned> wren{}; 
        ///Wait enable bit This bit              enables/disables wait-state insertion via the NWAIT              signal when accessing the memory in synchronous              mode.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(13,13),Register::ReadWriteAccess,unsigned> waiten{}; 
        ///Extended mode enable. This bit enables              the FMC to program the write timings for asynchronous              accesses inside the FMC_BWTR register, thus resulting              in different timings for read and write operations.              Note: When the extended mode is disabled, the FMC can              operate in Mode1 or Mode2 as follows: ** Mode 1 is              the default mode when the SRAM/PSRAM memory type is              selected (MTYP =0x0 or 0x01) ** Mode 2 is the default              mode when the NOR memory type is selected (MTYP =              0x10).
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(14,14),Register::ReadWriteAccess,unsigned> extmod{}; 
        ///Wait signal during asynchronous              transfers This bit enables/disables the FMC to use              the wait signal even during an asynchronous              protocol.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(15,15),Register::ReadWriteAccess,unsigned> asyncwait{}; 
        ///CRAM Page Size These are used for              Cellular RAM 1.5 which does not allow burst access to              cross the address boundaries between pages. When              these bits are configured, the FMC controller splits              automatically the burst access when the memory page              size is reached (refer to memory datasheet for page              size). Other configuration: reserved.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(18,16),Register::ReadWriteAccess,unsigned> cpsize{}; 
        ///Write burst enable For PSRAM (CRAM)              operating in Burst mode, the bit enables synchronous              accesses during write operations. The enable bit for              synchronous read accesses is the BURSTEN bit in the              FMC_BCRx register.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(19,19),Register::ReadWriteAccess,unsigned> cburstrw{}; 
        ///Continuous Clock Enable This bit enables              the FMC_CLK clock output to external memory devices.              Note: The CCLKEN bit of the FMC_BCR2..4 registers is              dont care. It is only enabled through the FMC_BCR1              register. Bank 1 must be configured in synchronous              mode to generate the FMC_CLK continuous clock. If              CCLKEN bit is set, the FMC_CLK clock ratio is              specified by CLKDIV value in the FMC_BTR1 register.              CLKDIV in FMC_BWTR1 is dont care. If the synchronous              mode is used and CCLKEN bit is set, the synchronous              memories connected to other banks than Bank 1 are              clocked by the same clock (the CLKDIV value in the              FMC_BTR2..4 and FMC_BWTR2..4 registers for other              banks has no effect.)
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(20,20),Register::ReadWriteAccess,unsigned> cclken{}; 
        ///Write FIFO Disable This bit disables the              Write FIFO used by the FMC controller. Note: The              WFDIS bit of the FMC_BCR2..4 registers is dont care.              It is only enabled through the FMC_BCR1              register.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(21,21),Register::ReadWriteAccess,unsigned> wfdis{}; 
        ///FMC bank mapping These bits allows              different to remap SDRAM bank2 or swap the FMC              NOR/PSRAM and SDRAM banks.Refer to Table 10 for Note:              The BMAP bits of the FMC_BCR2..4 registers are dont              care. It is only enabled through the FMC_BCR1              register.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(25,24),Register::ReadWriteAccess,unsigned> bmap{}; 
        ///FMC controller Enable This bit              enables/disables the FMC controller. Note: The FMCEN              bit of the FMC_BCR2..4 registers is dont care. It is              only enabled through the FMC_BCR1              register.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(31,31),Register::ReadWriteAccess,unsigned> fmcen{}; 
    }
    namespace FmcFmcBtr1{    ///<This register contains the control          information of each memory bank, used for SRAMs, PSRAM          and NOR Flash memories.If the EXTMOD bit is set in the          FMC_BCRx register, then this register is partitioned for          write and read access, that is, 2 registers are          available: one to configure read accesses (this register)          and one to configure write accesses (FMC_BWTRx          registers).
        using Addr = Register::Address<0x52004004,0xc0000000,0x00000000,std::uint32_t>;
        ///Address setup phase duration These bits              are written by software to define the duration of the              address setup phase (refer to Figure81 to Figure93),              used in SRAMs, ROMs and asynchronous NOR Flash: For              each access mode address setup phase duration, please              refer to the respective figure (refer to Figure81 to              Figure93). Note: In synchronous accesses, this value              is dont care. In Muxed mode or Mode D, the minimum              value for ADDSET is 1.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(3,0),Register::ReadWriteAccess,unsigned> addset{}; 
        ///Address-hold phase duration These bits              are written by software to define the duration of the              address hold phase (refer to Figure81 to Figure93),              used in mode D or multiplexed accesses: For each              access mode address-hold phase duration, please refer              to the respective figure (Figure81 to Figure93).              Note: In synchronous accesses, this value is not              used, the address hold phase is always 1 memory clock              period duration.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(7,4),Register::ReadWriteAccess,unsigned> addhld{}; 
        ///Data-phase duration These bits are              written by software to define the duration of the              data phase (refer to Figure81 to Figure93), used in              asynchronous accesses: For each memory type and              access mode data-phase duration, please refer to the              respective figure (Figure81 to Figure93). Example:              Mode1, write access, DATAST=1: Data-phase duration=              DATAST+1 = 2 KCK_FMC clock cycles. Note: In              synchronous accesses, this value is dont              care.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(15,8),Register::ReadWriteAccess,unsigned> datast{}; 
        ///Bus turnaround phase duration These bits              are written by software to add a delay at the end of              a write-to-read or read-to write transaction. The              programmed bus turnaround delay is inserted between              an asynchronous read (in muxed or mode D) or write              transaction and any other asynchronous /synchronous              read/write from/to a static bank. If a read operation              is performed, the bank can be the same or a different              one, whereas it must be different in case of write              operation to the bank, except in muxed mode or mode              D. In some cases, whatever the programmed BUSTRUN              values, the bus turnaround delay is fixed as follows:              The bus turnaround delay is not inserted between two              consecutive asynchronous write transfers to the same              static memory bank except in muxed mode and mode D.              There is a bus turnaround delay of 1 FMC clock cycle              between: Two consecutive asynchronous read transfers              to the same static memory bank except for modes muxed              and D. An asynchronous read to an asynchronous or              synchronous write to any static bank or dynamic bank              except in modes muxed and D mode. There is a bus              turnaround delay of 2 FMC clock cycle between: Two              consecutive synchronous write operations (in Burst or              Single mode) to the same bank. A synchronous write              (burst or single) access and an asynchronous write or              read transfer to or from static memory bank (the bank              can be the same or a different one in case of a read              operation. Two consecutive synchronous read              operations (in Burst or Single mode) followed by any              synchronous/asynchronous read or write from/to              another static memory bank. There is a bus turnaround              delay of 3 FMC clock cycle between: Two consecutive              synchronous write operations (in Burst or Single              mode) to different static banks. A synchronous write              access (in Burst or Single mode) and a synchronous              read from the same or a different bank. The bus              turnaround delay allows to match the minimum time              between consecutive transactions (tEHEL from NEx high              to NEx low) and the maximum time required by the              memory to free the data bus after a read access              (tEHQZ): (BUSTRUN + 1) KCK_FMC period &#8805;              tEHELmin and (BUSTRUN + 2)KCK_FMC period &#8805;              tEHQZmax if EXTMOD = 0 (BUSTRUN + 2)KCK_FMC period              &#8805; max (tEHELmin, tEHQZmax) if EXTMOD = 126.              ...
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(19,16),Register::ReadWriteAccess,unsigned> busturn{}; 
        ///Clock divide ratio (for FMC_CLK signal)              These bits define the period of FMC_CLK clock output              signal, expressed in number of KCK_FMC cycles: In              asynchronous NOR Flash, SRAM or PSRAM accesses, this              value is dont care. Note: Refer to Section20.6.5:              Synchronous transactions for FMC_CLK divider ratio              formula)
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(23,20),Register::ReadWriteAccess,unsigned> clkdiv{}; 
        ///Data latency for synchronous memory For              synchronous access with read write burst mode enabled              these bits define the number of memory clock              cycles
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(27,24),Register::ReadWriteAccess,unsigned> datlat{}; 
        ///Access mode These bits specify the              asynchronous access modes as shown in the timing              diagrams. They are taken into account only when the              EXTMOD bit in the FMC_BCRx register is              1.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(29,28),Register::ReadWriteAccess,unsigned> accmod{}; 
    }
    namespace FmcFmcBcr2{    ///<This register contains the control          information of each memory bank, used for SRAMs, PSRAM          and NOR Flash memories.
        using Addr = Register::Address<0x52004008,0x7cc00480,0x00000000,std::uint32_t>;
        ///Memory bank enable bit This bit enables              the memory bank. After reset Bank1 is enabled, all              others are disabled. Accessing a disabled bank causes              an ERROR on AXI bus.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(0,0),Register::ReadWriteAccess,unsigned> mbken{}; 
        ///Address/data multiplexing enable bit              When this bit is set, the address and data values are              multiplexed on the data bus, valid only with NOR and              PSRAM memories:
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(1,1),Register::ReadWriteAccess,unsigned> muxen{}; 
        ///Memory type These bits define the type              of external memory attached to the corresponding              memory bank:
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(3,2),Register::ReadWriteAccess,unsigned> mtyp{}; 
        ///Memory data bus width Defines the              external memory device width, valid for all type of              memories.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(5,4),Register::ReadWriteAccess,unsigned> mwid{}; 
        ///Flash access enable This bit enables NOR              Flash memory access operations.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(6,6),Register::ReadWriteAccess,unsigned> faccen{}; 
        ///Burst enable bit This bit              enables/disables synchronous accesses during read              operations. It is valid only for synchronous memories              operating in Burst mode:
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(8,8),Register::ReadWriteAccess,unsigned> bursten{}; 
        ///Wait signal polarity bit This bit              defines the polarity of the wait signal from memory              used for either in synchronous or asynchronous              mode:
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(9,9),Register::ReadWriteAccess,unsigned> waitpol{}; 
        ///Wait timing configuration The NWAIT              signal indicates whether the data from the memory are              valid or if a wait state must be inserted when              accessing the memory in synchronous mode. This              configuration bit determines if NWAIT is asserted by              the memory one clock cycle before the wait state or              during the wait state:
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(11,11),Register::ReadWriteAccess,unsigned> waitcfg{}; 
        ///Write enable bit This bit indicates              whether write operations are enabled/disabled in the              bank by the FMC:
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(12,12),Register::ReadWriteAccess,unsigned> wren{}; 
        ///Wait enable bit This bit              enables/disables wait-state insertion via the NWAIT              signal when accessing the memory in synchronous              mode.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(13,13),Register::ReadWriteAccess,unsigned> waiten{}; 
        ///Extended mode enable. This bit enables              the FMC to program the write timings for asynchronous              accesses inside the FMC_BWTR register, thus resulting              in different timings for read and write operations.              Note: When the extended mode is disabled, the FMC can              operate in Mode1 or Mode2 as follows: ** Mode 1 is              the default mode when the SRAM/PSRAM memory type is              selected (MTYP =0x0 or 0x01) ** Mode 2 is the default              mode when the NOR memory type is selected (MTYP =              0x10).
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(14,14),Register::ReadWriteAccess,unsigned> extmod{}; 
        ///Wait signal during asynchronous              transfers This bit enables/disables the FMC to use              the wait signal even during an asynchronous              protocol.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(15,15),Register::ReadWriteAccess,unsigned> asyncwait{}; 
        ///CRAM Page Size These are used for              Cellular RAM 1.5 which does not allow burst access to              cross the address boundaries between pages. When              these bits are configured, the FMC controller splits              automatically the burst access when the memory page              size is reached (refer to memory datasheet for page              size). Other configuration: reserved.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(18,16),Register::ReadWriteAccess,unsigned> cpsize{}; 
        ///Write burst enable For PSRAM (CRAM)              operating in Burst mode, the bit enables synchronous              accesses during write operations. The enable bit for              synchronous read accesses is the BURSTEN bit in the              FMC_BCRx register.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(19,19),Register::ReadWriteAccess,unsigned> cburstrw{}; 
        ///Continuous Clock Enable This bit enables              the FMC_CLK clock output to external memory devices.              Note: The CCLKEN bit of the FMC_BCR2..4 registers is              dont care. It is only enabled through the FMC_BCR1              register. Bank 1 must be configured in synchronous              mode to generate the FMC_CLK continuous clock. If              CCLKEN bit is set, the FMC_CLK clock ratio is              specified by CLKDIV value in the FMC_BTR1 register.              CLKDIV in FMC_BWTR1 is dont care. If the synchronous              mode is used and CCLKEN bit is set, the synchronous              memories connected to other banks than Bank 1 are              clocked by the same clock (the CLKDIV value in the              FMC_BTR2..4 and FMC_BWTR2..4 registers for other              banks has no effect.)
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(20,20),Register::ReadWriteAccess,unsigned> cclken{}; 
        ///Write FIFO Disable This bit disables the              Write FIFO used by the FMC controller. Note: The              WFDIS bit of the FMC_BCR2..4 registers is dont care.              It is only enabled through the FMC_BCR1              register.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(21,21),Register::ReadWriteAccess,unsigned> wfdis{}; 
        ///FMC bank mapping These bits allows              different to remap SDRAM bank2 or swap the FMC              NOR/PSRAM and SDRAM banks.Refer to Table 10 for Note:              The BMAP bits of the FMC_BCR2..4 registers are dont              care. It is only enabled through the FMC_BCR1              register.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(25,24),Register::ReadWriteAccess,unsigned> bmap{}; 
        ///FMC controller Enable This bit              enables/disables the FMC controller. Note: The FMCEN              bit of the FMC_BCR2..4 registers is dont care. It is              only enabled through the FMC_BCR1              register.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(31,31),Register::ReadWriteAccess,unsigned> fmcen{}; 
    }
    namespace FmcFmcBtr2{    ///<This register contains the control          information of each memory bank, used for SRAMs, PSRAM          and NOR Flash memories.If the EXTMOD bit is set in the          FMC_BCRx register, then this register is partitioned for          write and read access, that is, 2 registers are          available: one to configure read accesses (this register)          and one to configure write accesses (FMC_BWTRx          registers).
        using Addr = Register::Address<0x5200400c,0xc0000000,0x00000000,std::uint32_t>;
        ///Address setup phase duration These bits              are written by software to define the duration of the              address setup phase (refer to Figure81 to Figure93),              used in SRAMs, ROMs and asynchronous NOR Flash: For              each access mode address setup phase duration, please              refer to the respective figure (refer to Figure81 to              Figure93). Note: In synchronous accesses, this value              is dont care. In Muxed mode or Mode D, the minimum              value for ADDSET is 1.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(3,0),Register::ReadWriteAccess,unsigned> addset{}; 
        ///Address-hold phase duration These bits              are written by software to define the duration of the              address hold phase (refer to Figure81 to Figure93),              used in mode D or multiplexed accesses: For each              access mode address-hold phase duration, please refer              to the respective figure (Figure81 to Figure93).              Note: In synchronous accesses, this value is not              used, the address hold phase is always 1 memory clock              period duration.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(7,4),Register::ReadWriteAccess,unsigned> addhld{}; 
        ///Data-phase duration These bits are              written by software to define the duration of the              data phase (refer to Figure81 to Figure93), used in              asynchronous accesses: For each memory type and              access mode data-phase duration, please refer to the              respective figure (Figure81 to Figure93). Example:              Mode1, write access, DATAST=1: Data-phase duration=              DATAST+1 = 2 KCK_FMC clock cycles. Note: In              synchronous accesses, this value is dont              care.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(15,8),Register::ReadWriteAccess,unsigned> datast{}; 
        ///Bus turnaround phase duration These bits              are written by software to add a delay at the end of              a write-to-read or read-to write transaction. The              programmed bus turnaround delay is inserted between              an asynchronous read (in muxed or mode D) or write              transaction and any other asynchronous /synchronous              read/write from/to a static bank. If a read operation              is performed, the bank can be the same or a different              one, whereas it must be different in case of write              operation to the bank, except in muxed mode or mode              D. In some cases, whatever the programmed BUSTRUN              values, the bus turnaround delay is fixed as follows:              The bus turnaround delay is not inserted between two              consecutive asynchronous write transfers to the same              static memory bank except in muxed mode and mode D.              There is a bus turnaround delay of 1 FMC clock cycle              between: Two consecutive asynchronous read transfers              to the same static memory bank except for modes muxed              and D. An asynchronous read to an asynchronous or              synchronous write to any static bank or dynamic bank              except in modes muxed and D mode. There is a bus              turnaround delay of 2 FMC clock cycle between: Two              consecutive synchronous write operations (in Burst or              Single mode) to the same bank. A synchronous write              (burst or single) access and an asynchronous write or              read transfer to or from static memory bank (the bank              can be the same or a different one in case of a read              operation. Two consecutive synchronous read              operations (in Burst or Single mode) followed by any              synchronous/asynchronous read or write from/to              another static memory bank. There is a bus turnaround              delay of 3 FMC clock cycle between: Two consecutive              synchronous write operations (in Burst or Single              mode) to different static banks. A synchronous write              access (in Burst or Single mode) and a synchronous              read from the same or a different bank. The bus              turnaround delay allows to match the minimum time              between consecutive transactions (tEHEL from NEx high              to NEx low) and the maximum time required by the              memory to free the data bus after a read access              (tEHQZ): (BUSTRUN + 1) KCK_FMC period &#8805;              tEHELmin and (BUSTRUN + 2)KCK_FMC period &#8805;              tEHQZmax if EXTMOD = 0 (BUSTRUN + 2)KCK_FMC period              &#8805; max (tEHELmin, tEHQZmax) if EXTMOD = 1.              ...
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(19,16),Register::ReadWriteAccess,unsigned> busturn{}; 
        ///Clock divide ratio (for FMC_CLK signal)              These bits define the period of FMC_CLK clock output              signal, expressed in number of KCK_FMC cycles: In              asynchronous NOR Flash, SRAM or PSRAM accesses, this              value is dont care. Note: Refer to Section20.6.5:              Synchronous transactions for FMC_CLK divider ratio              formula)
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(23,20),Register::ReadWriteAccess,unsigned> clkdiv{}; 
        ///Data latency for synchronous memory For              synchronous access with read write burst mode enabled              these bits define the number of memory clock              cycles
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(27,24),Register::ReadWriteAccess,unsigned> datlat{}; 
        ///Access mode These bits specify the              asynchronous access modes as shown in the timing              diagrams. They are taken into account only when the              EXTMOD bit in the FMC_BCRx register is              1.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(29,28),Register::ReadWriteAccess,unsigned> accmod{}; 
    }
    namespace FmcFmcBcr3{    ///<This register contains the control          information of each memory bank, used for SRAMs, PSRAM          and NOR Flash memories.
        using Addr = Register::Address<0x52004010,0x7cc00480,0x00000000,std::uint32_t>;
        ///Memory bank enable bit This bit enables              the memory bank. After reset Bank1 is enabled, all              others are disabled. Accessing a disabled bank causes              an ERROR on AXI bus.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(0,0),Register::ReadWriteAccess,unsigned> mbken{}; 
        ///Address/data multiplexing enable bit              When this bit is set, the address and data values are              multiplexed on the data bus, valid only with NOR and              PSRAM memories:
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(1,1),Register::ReadWriteAccess,unsigned> muxen{}; 
        ///Memory type These bits define the type              of external memory attached to the corresponding              memory bank:
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(3,2),Register::ReadWriteAccess,unsigned> mtyp{}; 
        ///Memory data bus width Defines the              external memory device width, valid for all type of              memories.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(5,4),Register::ReadWriteAccess,unsigned> mwid{}; 
        ///Flash access enable This bit enables NOR              Flash memory access operations.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(6,6),Register::ReadWriteAccess,unsigned> faccen{}; 
        ///Burst enable bit This bit              enables/disables synchronous accesses during read              operations. It is valid only for synchronous memories              operating in Burst mode:
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(8,8),Register::ReadWriteAccess,unsigned> bursten{}; 
        ///Wait signal polarity bit This bit              defines the polarity of the wait signal from memory              used for either in synchronous or asynchronous              mode:
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(9,9),Register::ReadWriteAccess,unsigned> waitpol{}; 
        ///Wait timing configuration The NWAIT              signal indicates whether the data from the memory are              valid or if a wait state must be inserted when              accessing the memory in synchronous mode. This              configuration bit determines if NWAIT is asserted by              the memory one clock cycle before the wait state or              during the wait state:
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(11,11),Register::ReadWriteAccess,unsigned> waitcfg{}; 
        ///Write enable bit This bit indicates              whether write operations are enabled/disabled in the              bank by the FMC:
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(12,12),Register::ReadWriteAccess,unsigned> wren{}; 
        ///Wait enable bit This bit              enables/disables wait-state insertion via the NWAIT              signal when accessing the memory in synchronous              mode.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(13,13),Register::ReadWriteAccess,unsigned> waiten{}; 
        ///Extended mode enable. This bit enables              the FMC to program the write timings for asynchronous              accesses inside the FMC_BWTR register, thus resulting              in different timings for read and write operations.              Note: When the extended mode is disabled, the FMC can              operate in Mode1 or Mode2 as follows: ** Mode 1 is              the default mode when the SRAM/PSRAM memory type is              selected (MTYP =0x0 or 0x01) ** Mode 2 is the default              mode when the NOR memory type is selected (MTYP =              0x10).
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(14,14),Register::ReadWriteAccess,unsigned> extmod{}; 
        ///Wait signal during asynchronous              transfers This bit enables/disables the FMC to use              the wait signal even during an asynchronous              protocol.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(15,15),Register::ReadWriteAccess,unsigned> asyncwait{}; 
        ///CRAM Page Size These are used for              Cellular RAM 1.5 which does not allow burst access to              cross the address boundaries between pages. When              these bits are configured, the FMC controller splits              automatically the burst access when the memory page              size is reached (refer to memory datasheet for page              size). Other configuration: reserved.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(18,16),Register::ReadWriteAccess,unsigned> cpsize{}; 
        ///Write burst enable For PSRAM (CRAM)              operating in Burst mode, the bit enables synchronous              accesses during write operations. The enable bit for              synchronous read accesses is the BURSTEN bit in the              FMC_BCRx register.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(19,19),Register::ReadWriteAccess,unsigned> cburstrw{}; 
        ///Continuous Clock Enable This bit enables              the FMC_CLK clock output to external memory devices.              Note: The CCLKEN bit of the FMC_BCR2..4 registers is              dont care. It is only enabled through the FMC_BCR1              register. Bank 1 must be configured in synchronous              mode to generate the FMC_CLK continuous clock. If              CCLKEN bit is set, the FMC_CLK clock ratio is              specified by CLKDIV value in the FMC_BTR1 register.              CLKDIV in FMC_BWTR1 is dont care. If the synchronous              mode is used and CCLKEN bit is set, the synchronous              memories connected to other banks than Bank 1 are              clocked by the same clock (the CLKDIV value in the              FMC_BTR2..4 and FMC_BWTR2..4 registers for other              banks has no effect.)
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(20,20),Register::ReadWriteAccess,unsigned> cclken{}; 
        ///Write FIFO Disable This bit disables the              Write FIFO used by the FMC controller. Note: The              WFDIS bit of the FMC_BCR2..4 registers is dont care.              It is only enabled through the FMC_BCR1              register.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(21,21),Register::ReadWriteAccess,unsigned> wfdis{}; 
        ///FMC bank mapping These bits allows              different to remap SDRAM bank2 or swap the FMC              NOR/PSRAM and SDRAM banks.Refer to Table 10 for Note:              The BMAP bits of the FMC_BCR2..4 registers are dont              care. It is only enabled through the FMC_BCR1              register.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(25,24),Register::ReadWriteAccess,unsigned> bmap{}; 
        ///FMC controller Enable This bit              enables/disables the FMC controller. Note: The FMCEN              bit of the FMC_BCR2..4 registers is dont care. It is              only enabled through the FMC_BCR1              register.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(31,31),Register::ReadWriteAccess,unsigned> fmcen{}; 
    }
    namespace FmcFmcBtr3{    ///<This register contains the control          information of each memory bank, used for SRAMs, PSRAM          and NOR Flash memories.If the EXTMOD bit is set in the          FMC_BCRx register, then this register is partitioned for          write and read access, that is, 2 registers are          available: one to configure read accesses (this register)          and one to configure write accesses (FMC_BWTRx          registers).
        using Addr = Register::Address<0x52004014,0xc0000000,0x00000000,std::uint32_t>;
        ///Address setup phase duration These bits              are written by software to define the duration of the              address setup phase (refer to Figure81 to Figure93),              used in SRAMs, ROMs and asynchronous NOR Flash: For              each access mode address setup phase duration, please              refer to the respective figure (refer to Figure81 to              Figure93). Note: In synchronous accesses, this value              is dont care. In Muxed mode or Mode D, the minimum              value for ADDSET is 1.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(3,0),Register::ReadWriteAccess,unsigned> addset{}; 
        ///Address-hold phase duration These bits              are written by software to define the duration of the              address hold phase (refer to Figure81 to Figure93),              used in mode D or multiplexed accesses: For each              access mode address-hold phase duration, please refer              to the respective figure (Figure81 to Figure93).              Note: In synchronous accesses, this value is not              used, the address hold phase is always 1 memory clock              period duration.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(7,4),Register::ReadWriteAccess,unsigned> addhld{}; 
        ///Data-phase duration These bits are              written by software to define the duration of the              data phase (refer to Figure81 to Figure93), used in              asynchronous accesses: For each memory type and              access mode data-phase duration, please refer to the              respective figure (Figure81 to Figure93). Example:              Mode1, write access, DATAST=1: Data-phase duration=              DATAST+1 = 2 KCK_FMC clock cycles. Note: In              synchronous accesses, this value is dont              care.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(15,8),Register::ReadWriteAccess,unsigned> datast{}; 
        ///Bus turnaround phase duration These bits              are written by software to add a delay at the end of              a write-to-read or read-to write transaction. The              programmed bus turnaround delay is inserted between              an asynchronous read (in muxed or mode D) or write              transaction and any other asynchronous /synchronous              read/write from/to a static bank. If a read operation              is performed, the bank can be the same or a different              one, whereas it must be different in case of write              operation to the bank, except in muxed mode or mode              D. In some cases, whatever the programmed BUSTRUN              values, the bus turnaround delay is fixed as follows:              The bus turnaround delay is not inserted between two              consecutive asynchronous write transfers to the same              static memory bank except in muxed mode and mode D.              There is a bus turnaround delay of 1 FMC clock cycle              between: Two consecutive asynchronous read transfers              to the same static memory bank except for modes muxed              and D. An asynchronous read to an asynchronous or              synchronous write to any static bank or dynamic bank              except in modes muxed and D mode. There is a bus              turnaround delay of 2 FMC clock cycle between: Two              consecutive synchronous write operations (in Burst or              Single mode) to the same bank. A synchronous write              (burst or single) access and an asynchronous write or              read transfer to or from static memory bank (the bank              can be the same or a different one in case of a read              operation. Two consecutive synchronous read              operations (in Burst or Single mode) followed by any              synchronous/asynchronous read or write from/to              another static memory bank. There is a bus turnaround              delay of 3 FMC clock cycle between: Two consecutive              synchronous write operations (in Burst or Single              mode) to different static banks. A synchronous write              access (in Burst or Single mode) and a synchronous              read from the same or a different bank. The bus              turnaround delay allows to match the minimum time              between consecutive transactions (tEHEL from NEx high              to NEx low) and the maximum time required by the              memory to free the data bus after a read access              (tEHQZ): (BUSTRUN + 1) KCK_FMC period &#8805;              tEHELmin and (BUSTRUN + 2)KCK_FMC period &#8805;              tEHQZmax if EXTMOD = 0 (BUSTRUN + 2)KCK_FMC period              &#8805; max (tEHELmin, tEHQZmax) if EXTMOD =1.              ...
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(19,16),Register::ReadWriteAccess,unsigned> busturn{}; 
        ///Clock divide ratio (for FMC_CLK signal)              These bits define the period of FMC_CLK clock output              signal, expressed in number of KCK_FMC cycles: In              asynchronous NOR Flash, SRAM or PSRAM accesses, this              value is dont care. Note: Refer to Section20.6.5:              Synchronous transactions for FMC_CLK divider ratio              formula)
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(23,20),Register::ReadWriteAccess,unsigned> clkdiv{}; 
        ///Data latency for synchronous memory For              synchronous access with read write burst mode enabled              these bits define the number of memory clock              cycles
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(27,24),Register::ReadWriteAccess,unsigned> datlat{}; 
        ///Access mode These bits specify the              asynchronous access modes as shown in the timing              diagrams. They are taken into account only when the              EXTMOD bit in the FMC_BCRx register is              1.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(29,28),Register::ReadWriteAccess,unsigned> accmod{}; 
    }
    namespace FmcFmcBcr4{    ///<This register contains the control          information of each memory bank, used for SRAMs, PSRAM          and NOR Flash memories.
        using Addr = Register::Address<0x52004018,0x7cc00480,0x00000000,std::uint32_t>;
        ///Memory bank enable bit This bit enables              the memory bank. After reset Bank1 is enabled, all              others are disabled. Accessing a disabled bank causes              an ERROR on AXI bus.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(0,0),Register::ReadWriteAccess,unsigned> mbken{}; 
        ///Address/data multiplexing enable bit              When this bit is set, the address and data values are              multiplexed on the data bus, valid only with NOR and              PSRAM memories:
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(1,1),Register::ReadWriteAccess,unsigned> muxen{}; 
        ///Memory type These bits define the type              of external memory attached to the corresponding              memory bank:
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(3,2),Register::ReadWriteAccess,unsigned> mtyp{}; 
        ///Memory data bus width Defines the              external memory device width, valid for all type of              memories.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(5,4),Register::ReadWriteAccess,unsigned> mwid{}; 
        ///Flash access enable This bit enables NOR              Flash memory access operations.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(6,6),Register::ReadWriteAccess,unsigned> faccen{}; 
        ///Burst enable bit This bit              enables/disables synchronous accesses during read              operations. It is valid only for synchronous memories              operating in Burst mode:
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(8,8),Register::ReadWriteAccess,unsigned> bursten{}; 
        ///Wait signal polarity bit This bit              defines the polarity of the wait signal from memory              used for either in synchronous or asynchronous              mode:
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(9,9),Register::ReadWriteAccess,unsigned> waitpol{}; 
        ///Wait timing configuration The NWAIT              signal indicates whether the data from the memory are              valid or if a wait state must be inserted when              accessing the memory in synchronous mode. This              configuration bit determines if NWAIT is asserted by              the memory one clock cycle before the wait state or              during the wait state:
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(11,11),Register::ReadWriteAccess,unsigned> waitcfg{}; 
        ///Write enable bit This bit indicates              whether write operations are enabled/disabled in the              bank by the FMC:
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(12,12),Register::ReadWriteAccess,unsigned> wren{}; 
        ///Wait enable bit This bit              enables/disables wait-state insertion via the NWAIT              signal when accessing the memory in synchronous              mode.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(13,13),Register::ReadWriteAccess,unsigned> waiten{}; 
        ///Extended mode enable. This bit enables              the FMC to program the write timings for asynchronous              accesses inside the FMC_BWTR register, thus resulting              in different timings for read and write operations.              Note: When the extended mode is disabled, the FMC can              operate in Mode1 or Mode2 as follows: ** Mode 1 is              the default mode when the SRAM/PSRAM memory type is              selected (MTYP =0x0 or 0x01) ** Mode 2 is the default              mode when the NOR memory type is selected (MTYP =              0x10).
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(14,14),Register::ReadWriteAccess,unsigned> extmod{}; 
        ///Wait signal during asynchronous              transfers This bit enables/disables the FMC to use              the wait signal even during an asynchronous              protocol.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(15,15),Register::ReadWriteAccess,unsigned> asyncwait{}; 
        ///CRAM Page Size These are used for              Cellular RAM 1.5 which does not allow burst access to              cross the address boundaries between pages. When              these bits are configured, the FMC controller splits              automatically the burst access when the memory page              size is reached (refer to memory datasheet for page              size). Other configuration: reserved.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(18,16),Register::ReadWriteAccess,unsigned> cpsize{}; 
        ///Write burst enable For PSRAM (CRAM)              operating in Burst mode, the bit enables synchronous              accesses during write operations. The enable bit for              synchronous read accesses is the BURSTEN bit in the              FMC_BCRx register.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(19,19),Register::ReadWriteAccess,unsigned> cburstrw{}; 
        ///Continuous Clock Enable This bit enables              the FMC_CLK clock output to external memory devices.              Note: The CCLKEN bit of the FMC_BCR2..4 registers is              dont care. It is only enabled through the FMC_BCR1              register. Bank 1 must be configured in synchronous              mode to generate the FMC_CLK continuous clock. If              CCLKEN bit is set, the FMC_CLK clock ratio is              specified by CLKDIV value in the FMC_BTR1 register.              CLKDIV in FMC_BWTR1 is dont care. If the synchronous              mode is used and CCLKEN bit is set, the synchronous              memories connected to other banks than Bank 1 are              clocked by the same clock (the CLKDIV value in the              FMC_BTR2..4 and FMC_BWTR2..4 registers for other              banks has no effect.)
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(20,20),Register::ReadWriteAccess,unsigned> cclken{}; 
        ///Write FIFO Disable This bit disables the              Write FIFO used by the FMC controller. Note: The              WFDIS bit of the FMC_BCR2..4 registers is dont care.              It is only enabled through the FMC_BCR1              register.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(21,21),Register::ReadWriteAccess,unsigned> wfdis{}; 
        ///FMC bank mapping These bits allows              different to remap SDRAM bank2 or swap the FMC              NOR/PSRAM and SDRAM banks.Refer to Table 10 for Note:              The BMAP bits of the FMC_BCR2..4 registers are dont              care. It is only enabled through the FMC_BCR1              register.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(25,24),Register::ReadWriteAccess,unsigned> bmap{}; 
        ///FMC controller Enable This bit              enables/disables the FMC controller. Note: The FMCEN              bit of the FMC_BCR2..4 registers is dont care. It is              only enabled through the FMC_BCR1              register.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(31,31),Register::ReadWriteAccess,unsigned> fmcen{}; 
    }
    namespace FmcFmcBtr4{    ///<This register contains the control          information of each memory bank, used for SRAMs, PSRAM          and NOR Flash memories.If the EXTMOD bit is set in the          FMC_BCRx register, then this register is partitioned for          write and read access, that is, 2 registers are          available: one to configure read accesses (this register)          and one to configure write accesses (FMC_BWTRx          registers).
        using Addr = Register::Address<0x5200401c,0xc0000000,0x00000000,std::uint32_t>;
        ///Address setup phase duration These bits              are written by software to define the duration of the              address setup phase (refer to Figure81 to Figure93),              used in SRAMs, ROMs and asynchronous NOR Flash: For              each access mode address setup phase duration, please              refer to the respective figure (refer to Figure81 to              Figure93). Note: In synchronous accesses, this value              is dont care. In Muxed mode or Mode D, the minimum              value for ADDSET is 1.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(3,0),Register::ReadWriteAccess,unsigned> addset{}; 
        ///Address-hold phase duration These bits              are written by software to define the duration of the              address hold phase (refer to Figure81 to Figure93),              used in mode D or multiplexed accesses: For each              access mode address-hold phase duration, please refer              to the respective figure (Figure81 to Figure93).              Note: In synchronous accesses, this value is not              used, the address hold phase is always 1 memory clock              period duration.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(7,4),Register::ReadWriteAccess,unsigned> addhld{}; 
        ///Data-phase duration These bits are              written by software to define the duration of the              data phase (refer to Figure81 to Figure93), used in              asynchronous accesses: For each memory type and              access mode data-phase duration, please refer to the              respective figure (Figure81 to Figure93). Example:              Mode1, write access, DATAST=1: Data-phase duration=              DATAST+1 = 2 KCK_FMC clock cycles. Note: In              synchronous accesses, this value is dont              care.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(15,8),Register::ReadWriteAccess,unsigned> datast{}; 
        ///Bus turnaround phase duration These bits              are written by software to add a delay at the end of              a write-to-read or read-to write transaction. The              programmed bus turnaround delay is inserted between              an asynchronous read (in muxed or mode D) or write              transaction and any other asynchronous /synchronous              read/write from/to a static bank. If a read operation              is performed, the bank can be the same or a different              one, whereas it must be different in case of write              operation to the bank, except in muxed mode or mode              D. In some cases, whatever the programmed BUSTRUN              values, the bus turnaround delay is fixed as follows:              The bus turnaround delay is not inserted between two              consecutive asynchronous write transfers to the same              static memory bank except in muxed mode and mode D.              There is a bus turnaround delay of 1 FMC clock cycle              between: Two consecutive asynchronous read transfers              to the same static memory bank except for modes muxed              and D. An asynchronous read to an asynchronous or              synchronous write to any static bank or dynamic bank              except in modes muxed and D mode. There is a bus              turnaround delay of 2 FMC clock cycle between: Two              consecutive synchronous write operations (in Burst or              Single mode) to the same bank. A synchronous write              (burst or single) access and an asynchronous write or              read transfer to or from static memory bank (the bank              can be the same or a different one in case of a read              operation. Two consecutive synchronous read              operations (in Burst or Single mode) followed by any              synchronous/asynchronous read or write from/to              another static memory bank. There is a bus turnaround              delay of 3 FMC clock cycle between: Two consecutive              synchronous write operations (in Burst or Single              mode) to different static banks. A synchronous write              access (in Burst or Single mode) and a synchronous              read from the same or a different bank. The bus              turnaround delay allows to match the minimum time              between consecutive transactions (tEHEL from NEx high              to NEx low) and the maximum time required by the              memory to free the data bus after a read access              (tEHQZ): (BUSTRUN + 1) KCK_FMC period &#8805;              tEHELmin and (BUSTRUN + 2)KCK_FMC period &#8805;              tEHQZmax if EXTMOD = 0 (BUSTRUN + 2)KCK_FMC period              &#8805; max (tEHELmin, tEHQZmax) if EXTMOD =1.              ...
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(19,16),Register::ReadWriteAccess,unsigned> busturn{}; 
        ///Clock divide ratio (for FMC_CLK signal)              These bits define the period of FMC_CLK clock output              signal, expressed in number of KCK_FMC cycles: In              asynchronous NOR Flash, SRAM or PSRAM accesses, this              value is dont care. Note: Refer to Section20.6.5:              Synchronous transactions for FMC_CLK divider ratio              formula)
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(23,20),Register::ReadWriteAccess,unsigned> clkdiv{}; 
        ///Data latency for synchronous memory For              synchronous access with read write burst mode enabled              these bits define the number of memory clock              cycles
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(27,24),Register::ReadWriteAccess,unsigned> datlat{}; 
        ///Access mode These bits specify the              asynchronous access modes as shown in the timing              diagrams. They are taken into account only when the              EXTMOD bit in the FMC_BCRx register is              1.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(29,28),Register::ReadWriteAccess,unsigned> accmod{}; 
    }
    namespace FmcFmcPcr{    ///<NAND Flash control registers
        using Addr = Register::Address<0x52004080,0xfff00189,0x00000000,std::uint32_t>;
        ///Wait feature enable bit. This bit              enables the Wait feature for the NAND Flash memory              bank:
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(1,1),Register::ReadWriteAccess,unsigned> pwaiten{}; 
        ///NAND Flash memory bank enable bit. This              bit enables the memory bank. Accessing a disabled              memory bank causes an ERROR on AXI bus
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(2,2),Register::ReadWriteAccess,unsigned> pbken{}; 
        ///Data bus width. These bits define the              external memory device width.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(5,4),Register::ReadWriteAccess,unsigned> pwid{}; 
        ///ECC computation logic enable              bit
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(6,6),Register::ReadWriteAccess,unsigned> eccen{}; 
        ///CLE to RE delay. These bits set time              from CLE low to RE low in number of KCK_FMC clock              cycles. The time is give by the following formula:              t_clr = (TCLR + SET + 2) TKCK_FMC where TKCK_FMC is              the KCK_FMC clock period Note: Set is MEMSET or              ATTSET according to the addressed              space.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(12,9),Register::ReadWriteAccess,unsigned> tclr{}; 
        ///ALE to RE delay. These bits set time              from ALE low to RE low in number of KCK_FMC clock              cycles. Time is: t_ar = (TAR + SET + 2) TKCK_FMC              where TKCK_FMC is the FMC clock period Note: Set is              MEMSET or ATTSET according to the addressed              space.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(16,13),Register::ReadWriteAccess,unsigned> tar{}; 
        ///ECC page size. These bits define the              page size for the extended ECC:
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(19,17),Register::ReadWriteAccess,unsigned> eccps{}; 
    }
    namespace FmcFmcSr{    ///<This register contains information about the          FIFO status and interrupt. The FMC features a FIFO that          is used when writing to memories to transfer up to 16          words of data.This is used to quickly write to the FIFO          and free the AXI bus for transactions to peripherals          other than the FMC, while the FMC is draining its FIFO          into the memory. One of these register bits indicates the          status of the FIFO, for ECC purposes.The ECC is          calculated while the data are written to the memory. To          read the correct ECC, the software must consequently wait          until the FIFO is empty.
        using Addr = Register::Address<0x52004084,0xffffff80,0x00000000,std::uint32_t>;
        ///Interrupt rising edge status The flag is              set by hardware and reset by software. Note: If this              bit is written by software to 1 it will be              set.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(0,0),Register::ReadWriteAccess,unsigned> irs{}; 
        ///Interrupt high-level status The flag is              set by hardware and reset by software.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(1,1),Register::ReadWriteAccess,unsigned> ils{}; 
        ///Interrupt falling edge status The flag              is set by hardware and reset by software. Note: If              this bit is written by software to 1 it will be              set.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(2,2),Register::ReadWriteAccess,unsigned> ifs{}; 
        ///Interrupt rising edge detection enable              bit
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(3,3),Register::ReadWriteAccess,unsigned> iren{}; 
        ///Interrupt high-level detection enable              bit
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(4,4),Register::ReadWriteAccess,unsigned> ilen{}; 
        ///Interrupt falling edge detection enable              bit
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(5,5),Register::ReadWriteAccess,unsigned> ifen{}; 
        ///FIFO empty. Read-only bit that provides              the status of the FIFO
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(6,6),Register::Access<Register::AccessType::readOnly,Register::ReadActionType::normal,Register::ModifiedWriteValueType::normal>,unsigned> fempt{}; 
    }
    namespace FmcFmcPmem{    ///<The FMC_PMEM read/write register contains          the timing information for NAND Flash memory bank. This          information is used to access either the common memory          space of the NAND Flash for command, address write access          and data read/write access.
        using Addr = Register::Address<0x52004088,0x00000000,0x00000000,std::uint32_t>;
        ///Common memory x setup time These bits              define the number of KCK_FMC (+1) clock cycles to set              up the address before the command assertion (NWE,              NOE), for NAND Flash read or write access to common              memory space:
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(7,0),Register::ReadWriteAccess,unsigned> memset{}; 
        ///Common memory wait time These bits              define the minimum number of KCK_FMC (+1) clock              cycles to assert the command (NWE, NOE), for NAND              Flash read or write access to common memory space.              The duration of command assertion is extended if the              wait signal (NWAIT) is active (low) at the end of the              programmed value of KCK_FMC:
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(15,8),Register::ReadWriteAccess,unsigned> memwait{}; 
        ///Common memory hold time These bits              define the number of KCK_FMC clock cycles for write              accesses and KCK_FMC+1 clock cycles for read accesses              during which the address is held (and data for write              accesses) after the command is de-asserted (NWE,              NOE), for NAND Flash read or write access to common              memory space:
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(23,16),Register::ReadWriteAccess,unsigned> memhold{}; 
        ///Common memory x data bus Hi-Z time These              bits define the number of KCK_FMC clock cycles during              which the data bus is kept Hi-Z after the start of a              NAND Flash write access to common memory space. This              is only valid for write transactions:
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(31,24),Register::ReadWriteAccess,unsigned> memhiz{}; 
    }
    namespace FmcFmcPatt{    ///<The FMC_PATT read/write register contains          the timing information for NAND Flash memory bank. It is          used for 8-bit accesses to the attribute memory space of          the NAND Flash for the last address write access if the          timing must differ from that of previous accesses (for          Ready/Busy management, refer to Section20.8.5: NAND Flash          prewait feature).
        using Addr = Register::Address<0x5200408c,0x00000000,0x00000000,std::uint32_t>;
        ///Attribute memory setup time These bits              define the number of KCK_FMC (+1) clock cycles to set              up address before the command assertion (NWE, NOE),              for NAND Flash read or write access to attribute              memory space:
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(7,0),Register::ReadWriteAccess,unsigned> attset{}; 
        ///Attribute memory wait time These bits              define the minimum number of x KCK_FMC (+1) clock              cycles to assert the command (NWE, NOE), for NAND              Flash read or write access to attribute memory space.              The duration for command assertion is extended if the              wait signal (NWAIT) is active (low) at the end of the              programmed value of KCK_FMC:
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(15,8),Register::ReadWriteAccess,unsigned> attwait{}; 
        ///Attribute memory hold time These bits              define the number of KCK_FMC clock cycles during              which the address is held (and data for write access)              after the command de-assertion (NWE, NOE), for NAND              Flash read or write access to attribute memory              space:
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(23,16),Register::ReadWriteAccess,unsigned> atthold{}; 
        ///Attribute memory data bus Hi-Z time              These bits define the number of KCK_FMC clock cycles              during which the data bus is kept in Hi-Z after the              start of a NAND Flash write access to attribute              memory space on socket. Only valid for writ              transaction:
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(31,24),Register::ReadWriteAccess,unsigned> atthiz{}; 
    }
    namespace FmcFmcEccr{    ///<This register contain the current error          correction code value computed by the ECC computation          modules of the FMC NAND controller. When the CPU          reads/writes the data from a NAND Flash memory page at          the correct address (refer to Section20.8.6: Computation          of the error correction code (ECC) in NAND Flash memory),          the data read/written from/to the NAND Flash memory are          processed automatically by the ECC computation module.          When X bytes have been read (according to the ECCPS field          in the FMC_PCR registers), the CPU must read the computed          ECC value from the FMC_ECC registers. It then verifies if          these computed parity data are the same as the parity          value recorded in the spare area, to determine whether a          page is valid, and, to correct it otherwise. The FMC_ECCR          register should be cleared after being read by setting          the ECCEN bit to 0. To compute a new data block, the          ECCEN bit must be set to 1.
        using Addr = Register::Address<0x52004094,0x00000000,0x00000000,std::uint32_t>;
        ///ECC result This field contains the value              computed by the ECC computation logic. Table167              describes the contents of these bit              fields.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(31,0),Register::ReadWriteAccess,unsigned> ecc{}; 
    }
    namespace FmcFmcBwtr1{    ///<This register contains the control          information of each memory bank. It is used for SRAMs,          PSRAMs and NOR Flash memories. When the EXTMOD bit is set          in the FMC_BCRx register, then this register is active          for write access.
        using Addr = Register::Address<0x52004104,0xcff00000,0x00000000,std::uint32_t>;
        ///Address setup phase duration. These bits              are written by software to define the duration of the              address setup phase in KCK_FMC cycles (refer to              Figure81 to Figure93), used in asynchronous accesses:              ... Note: In synchronous accesses, this value is not              used, the address setup phase is always 1 Flash clock              period duration. In muxed mode, the minimum ADDSET              value is 1.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(3,0),Register::ReadWriteAccess,unsigned> addset{}; 
        ///Address-hold phase duration. These bits              are written by software to define the duration of the              address hold phase (refer to Figure81 to Figure93),              used in asynchronous multiplexed accesses: ... Note:              In synchronous NOR Flash accesses, this value is not              used, the address hold phase is always 1 Flash clock              period duration.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(7,4),Register::ReadWriteAccess,unsigned> addhld{}; 
        ///Data-phase duration. These bits are              written by software to define the duration of the              data phase (refer to Figure81 to Figure93), used in              asynchronous SRAM, PSRAM and NOR Flash memory              accesses:
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(15,8),Register::ReadWriteAccess,unsigned> datast{}; 
        ///Bus turnaround phase duration These bits              are written by software to add a delay at the end of              a write transaction to match the minimum time between              consecutive transactions (tEHEL from ENx high to ENx              low): (BUSTRUN + 1) KCK_FMC period &#8805;              tEHELmin. The programmed bus turnaround delay is              inserted between a an asynchronous write transfer and              any other asynchronous /synchronous read or write              transfer to or from a static bank. If a read              operation is performed, the bank can be the same or a              different one, whereas it must be different in case              of write operation to the bank, except in muxed mode              or mode D. In some cases, whatever the programmed              BUSTRUN values, the bus turnaround delay is fixed as              follows: The bus turnaround delay is not inserted              between two consecutive asynchronous write transfers              to the same static memory bank except for muxed mode              and mode D. There is a bus turnaround delay of 2 FMC              clock cycle between: Two consecutive synchronous              write operations (in Burst or Single mode) to the              same bank A synchronous write transfer ((in Burst or              Single mode) and an asynchronous write or read              transfer to or from static memory bank. There is a              bus turnaround delay of 3 FMC clock cycle between:              Two consecutive synchronous write operations (in              Burst or Single mode) to different static banks. A              synchronous write transfer (in Burst or Single mode)              and a synchronous read from the same or a different              bank. ...
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(19,16),Register::ReadWriteAccess,unsigned> busturn{}; 
        ///Access mode. These bits specify the              asynchronous access modes as shown in the next timing              diagrams.These bits are taken into account only when              the EXTMOD bit in the FMC_BCRx register is              1.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(29,28),Register::ReadWriteAccess,unsigned> accmod{}; 
    }
    namespace FmcFmcBwtr2{    ///<This register contains the control          information of each memory bank. It is used for SRAMs,          PSRAMs and NOR Flash memories. When the EXTMOD bit is set          in the FMC_BCRx register, then this register is active          for write access.
        using Addr = Register::Address<0x5200410c,0xcff00000,0x00000000,std::uint32_t>;
        ///Address setup phase duration. These bits              are written by software to define the duration of the              address setup phase in KCK_FMC cycles (refer to              Figure81 to Figure93), used in asynchronous accesses:              ... Note: In synchronous accesses, this value is not              used, the address setup phase is always 1 Flash clock              period duration. In muxed mode, the minimum ADDSET              value is 1.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(3,0),Register::ReadWriteAccess,unsigned> addset{}; 
        ///Address-hold phase duration. These bits              are written by software to define the duration of the              address hold phase (refer to Figure81 to Figure93),              used in asynchronous multiplexed accesses: ... Note:              In synchronous NOR Flash accesses, this value is not              used, the address hold phase is always 1 Flash clock              period duration.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(7,4),Register::ReadWriteAccess,unsigned> addhld{}; 
        ///Data-phase duration. These bits are              written by software to define the duration of the              data phase (refer to Figure81 to Figure93), used in              asynchronous SRAM, PSRAM and NOR Flash memory              accesses:
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(15,8),Register::ReadWriteAccess,unsigned> datast{}; 
        ///Bus turnaround phase duration These bits              are written by software to add a delay at the end of              a write transaction to match the minimum time between              consecutive transactions (tEHEL from ENx high to ENx              low): (BUSTRUN + 1) KCK_FMC period &#8805;              tEHELmin. The programmed bus turnaround delay is              inserted between a an asynchronous write transfer and              any other asynchronous /synchronous read or write              transfer to or from a static bank. If a read              operation is performed, the bank can be the same or a              different one, whereas it must be different in case              of write operation to the bank, except in muxed mode              or mode D. In some cases, whatever the programmed              BUSTRUN values, the bus turnaround delay is fixed as              follows: The bus turnaround delay is not inserted              between two consecutive asynchronous write transfers              to the same static memory bank except for muxed mode              and mode D. There is a bus turnaround delay of 2 FMC              clock cycle between: Two consecutive synchronous              write operations (in Burst or Single mode) to the              same bank A synchronous write transfer ((in Burst or              Single mode) and an asynchronous write or read              transfer to or from static memory bank. There is a              bus turnaround delay of 3 FMC clock cycle between:              Two consecutive synchronous write operations (in              Burst or Single mode) to different static banks. A              synchronous write transfer (in Burst or Single mode)              and a synchronous read from the same or a different              bank. ...
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(19,16),Register::ReadWriteAccess,unsigned> busturn{}; 
        ///Access mode. These bits specify the              asynchronous access modes as shown in the next timing              diagrams.These bits are taken into account only when              the EXTMOD bit in the FMC_BCRx register is              1.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(29,28),Register::ReadWriteAccess,unsigned> accmod{}; 
    }
    namespace FmcFmcBwtr3{    ///<This register contains the control          information of each memory bank. It is used for SRAMs,          PSRAMs and NOR Flash memories. When the EXTMOD bit is set          in the FMC_BCRx register, then this register is active          for write access.
        using Addr = Register::Address<0x52004114,0xcff00000,0x00000000,std::uint32_t>;
        ///Address setup phase duration. These bits              are written by software to define the duration of the              address setup phase in KCK_FMC cycles (refer to              Figure81 to Figure93), used in asynchronous accesses:              ... Note: In synchronous accesses, this value is not              used, the address setup phase is always 1 Flash clock              period duration. In muxed mode, the minimum ADDSET              value is 1.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(3,0),Register::ReadWriteAccess,unsigned> addset{}; 
        ///Address-hold phase duration. These bits              are written by software to define the duration of the              address hold phase (refer to Figure81 to Figure93),              used in asynchronous multiplexed accesses: ... Note:              In synchronous NOR Flash accesses, this value is not              used, the address hold phase is always 1 Flash clock              period duration.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(7,4),Register::ReadWriteAccess,unsigned> addhld{}; 
        ///Data-phase duration. These bits are              written by software to define the duration of the              data phase (refer to Figure81 to Figure93), used in              asynchronous SRAM, PSRAM and NOR Flash memory              accesses:
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(15,8),Register::ReadWriteAccess,unsigned> datast{}; 
        ///Bus turnaround phase duration These bits              are written by software to add a delay at the end of              a write transaction to match the minimum time between              consecutive transactions (tEHEL from ENx high to ENx              low): (BUSTRUN + 1) KCK_FMC period &#8805;              tEHELmin. The programmed bus turnaround delay is              inserted between a an asynchronous write transfer and              any other asynchronous /synchronous read or write              transfer to or from a static bank. If a read              operation is performed, the bank can be the same or a              different one, whereas it must be different in case              of write operation to the bank, except in muxed mode              or mode D. In some cases, whatever the programmed              BUSTRUN values, the bus turnaround delay is fixed as              follows: The bus turnaround delay is not inserted              between two consecutive asynchronous write transfers              to the same static memory bank except for muxed mode              and mode D. There is a bus turnaround delay of 2 FMC              clock cycle between: Two consecutive synchronous              write operations (in Burst or Single mode) to the              same bank A synchronous write transfer ((in Burst or              Single mode) and an asynchronous write or read              transfer to or from static memory bank. There is a              bus turnaround delay of 3 FMC clock cycle between:              Two consecutive synchronous write operations (in              Burst or Single mode) to different static banks. A              synchronous write transfer (in Burst or Single mode)              and a synchronous read from the same or a different              bank. ...
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(19,16),Register::ReadWriteAccess,unsigned> busturn{}; 
        ///Access mode. These bits specify the              asynchronous access modes as shown in the next timing              diagrams.These bits are taken into account only when              the EXTMOD bit in the FMC_BCRx register is              1.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(29,28),Register::ReadWriteAccess,unsigned> accmod{}; 
    }
    namespace FmcFmcBwtr4{    ///<This register contains the control          information of each memory bank. It is used for SRAMs,          PSRAMs and NOR Flash memories. When the EXTMOD bit is set          in the FMC_BCRx register, then this register is active          for write access.
        using Addr = Register::Address<0x5200411c,0xcff00000,0x00000000,std::uint32_t>;
        ///Address setup phase duration. These bits              are written by software to define the duration of the              address setup phase in KCK_FMC cycles (refer to              Figure81 to Figure93), used in asynchronous accesses:              ... Note: In synchronous accesses, this value is not              used, the address setup phase is always 1 Flash clock              period duration. In muxed mode, the minimum ADDSET              value is 1.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(3,0),Register::ReadWriteAccess,unsigned> addset{}; 
        ///Address-hold phase duration. These bits              are written by software to define the duration of the              address hold phase (refer to Figure81 to Figure93),              used in asynchronous multiplexed accesses: ... Note:              In synchronous NOR Flash accesses, this value is not              used, the address hold phase is always 1 Flash clock              period duration.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(7,4),Register::ReadWriteAccess,unsigned> addhld{}; 
        ///Data-phase duration. These bits are              written by software to define the duration of the              data phase (refer to Figure81 to Figure93), used in              asynchronous SRAM, PSRAM and NOR Flash memory              accesses:
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(15,8),Register::ReadWriteAccess,unsigned> datast{}; 
        ///Bus turnaround phase duration These bits              are written by software to add a delay at the end of              a write transaction to match the minimum time between              consecutive transactions (tEHEL from ENx high to ENx              low): (BUSTRUN + 1) KCK_FMC period &#8805;              tEHELmin. The programmed bus turnaround delay is              inserted between a an asynchronous write transfer and              any other asynchronous /synchronous read or write              transfer to or from a static bank. If a read              operation is performed, the bank can be the same or a              different one, whereas it must be different in case              of write operation to the bank, except in muxed mode              or mode D. In some cases, whatever the programmed              BUSTRUN values, the bus turnaround delay is fixed as              follows: The bus turnaround delay is not inserted              between two consecutive asynchronous write transfers              to the same static memory bank except for muxed mode              and mode D. There is a bus turnaround delay of 2 FMC              clock cycle between: Two consecutive synchronous              write operations (in Burst or Single mode) to the              same bank A synchronous write transfer ((in Burst or              Single mode) and an asynchronous write or read              transfer to or from static memory bank. There is a              bus turnaround delay of 3 FMC clock cycle between:              Two consecutive synchronous write operations (in              Burst or Single mode) to different static banks. A              synchronous write transfer (in Burst or Single mode)              and a synchronous read from the same or a different              bank. ...
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(19,16),Register::ReadWriteAccess,unsigned> busturn{}; 
        ///Access mode. These bits specify the              asynchronous access modes as shown in the next timing              diagrams.These bits are taken into account only when              the EXTMOD bit in the FMC_BCRx register is              1.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(29,28),Register::ReadWriteAccess,unsigned> accmod{}; 
    }
    namespace FmcFmcSdcr1{    ///<This register contains the control          parameters for each SDRAM memory bank
        using Addr = Register::Address<0x52004140,0xffff8000,0x00000000,std::uint32_t>;
        ///Number of column address bits These bits              define the number of bits of a column              address.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(1,0),Register::ReadWriteAccess,unsigned> nc{}; 
        ///Number of row address bits These bits              define the number of bits of a row              address.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(3,2),Register::ReadWriteAccess,unsigned> nr{}; 
        ///Memory data bus width. These bits define              the memory device width.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(5,4),Register::ReadWriteAccess,unsigned> mwid{}; 
        ///Number of internal banks This bit sets              the number of internal banks.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(6,6),Register::ReadWriteAccess,unsigned> nb{}; 
        ///CAS Latency This bits sets the SDRAM CAS              latency in number of memory clock              cycles
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(8,7),Register::ReadWriteAccess,unsigned> cas{}; 
        ///Write protection This bit enables write              mode access to the SDRAM bank.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(9,9),Register::ReadWriteAccess,unsigned> wp{}; 
        ///SDRAM clock configuration These bits              define the SDRAM clock period for both SDRAM banks              and allow disabling the clock before changing the              frequency. In this case the SDRAM must be              re-initialized. Note: The corresponding bits in the              FMC_SDCR2 register is read only.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(11,10),Register::ReadWriteAccess,unsigned> sdclk{}; 
        ///Burst read This bit enables burst read              mode. The SDRAM controller anticipates the next read              commands during the CAS latency and stores data in              the Read FIFO. Note: The corresponding bit in the              FMC_SDCR2 register is read only.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(12,12),Register::ReadWriteAccess,unsigned> rburst{}; 
        ///Read pipe These bits define the delay,              in KCK_FMC clock cycles, for reading data after CAS              latency. Note: The corresponding bits in the              FMC_SDCR2 register is read only.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(14,13),Register::ReadWriteAccess,unsigned> rpipe{}; 
    }
    namespace FmcFmcSdcr2{    ///<This register contains the control          parameters for each SDRAM memory bank
        using Addr = Register::Address<0x52004144,0xffff8000,0x00000000,std::uint32_t>;
        ///Number of column address bits These bits              define the number of bits of a column              address.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(1,0),Register::ReadWriteAccess,unsigned> nc{}; 
        ///Number of row address bits These bits              define the number of bits of a row              address.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(3,2),Register::ReadWriteAccess,unsigned> nr{}; 
        ///Memory data bus width. These bits define              the memory device width.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(5,4),Register::ReadWriteAccess,unsigned> mwid{}; 
        ///Number of internal banks This bit sets              the number of internal banks.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(6,6),Register::ReadWriteAccess,unsigned> nb{}; 
        ///CAS Latency This bits sets the SDRAM CAS              latency in number of memory clock              cycles
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(8,7),Register::ReadWriteAccess,unsigned> cas{}; 
        ///Write protection This bit enables write              mode access to the SDRAM bank.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(9,9),Register::ReadWriteAccess,unsigned> wp{}; 
        ///SDRAM clock configuration These bits              define the SDRAM clock period for both SDRAM banks              and allow disabling the clock before changing the              frequency. In this case the SDRAM must be              re-initialized. Note: The corresponding bits in the              FMC_SDCR2 register is read only.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(11,10),Register::ReadWriteAccess,unsigned> sdclk{}; 
        ///Burst read This bit enables burst read              mode. The SDRAM controller anticipates the next read              commands during the CAS latency and stores data in              the Read FIFO. Note: The corresponding bit in the              FMC_SDCR2 register is read only.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(12,12),Register::ReadWriteAccess,unsigned> rburst{}; 
        ///Read pipe These bits define the delay,              in KCK_FMC clock cycles, for reading data after CAS              latency. Note: The corresponding bits in the              FMC_SDCR2 register is read only.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(14,13),Register::ReadWriteAccess,unsigned> rpipe{}; 
    }
    namespace FmcFmcSdtr1{    ///<This register contains the timing parameters          of each SDRAM bank
        using Addr = Register::Address<0x52004148,0xf0000000,0x00000000,std::uint32_t>;
        ///Load Mode Register to Active These bits              define the delay between a Load Mode Register command              and an Active or Refresh command in number of memory              clock cycles. ....
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(3,0),Register::ReadWriteAccess,unsigned> tmrd{}; 
        ///Exit Self-refresh delay These bits              define the delay from releasing the Self-refresh              command to issuing the Activate command in number of              memory clock cycles. .... Note: If two SDRAM devices              are used, the FMC_SDTR1 and FMC_SDTR2 must be              programmed with the same TXSR timing corresponding to              the slowest SDRAM device.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(7,4),Register::ReadWriteAccess,unsigned> txsr{}; 
        ///Self refresh time These bits define the              minimum Self-refresh period in number of memory clock              cycles. ....
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(11,8),Register::ReadWriteAccess,unsigned> tras{}; 
        ///Row cycle delay These bits define the              delay between the Refresh command and the Activate              command, as well as the delay between two consecutive              Refresh commands. It is expressed in number of memory              clock cycles. The TRC timing is only configured in              the FMC_SDTR1 register. If two SDRAM devices are              used, the TRC must be programmed with the timings of              the slowest device. .... Note: TRC must match the TRC              and TRFC (Auto Refresh period) timings defined in the              SDRAM device datasheet. Note: The corresponding bits              in the FMC_SDTR2 register are dont              care.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(15,12),Register::ReadWriteAccess,unsigned> trc{}; 
        ///Recovery delay These bits define the              delay between a Write and a Precharge command in              number of memory clock cycles. .... Note: TWR must be              programmed to match the write recovery time (tWR)              defined in the SDRAM datasheet, and to guarantee              that: TWR &#8805; TRAS - TRCD and TWR              &#8805;TRC - TRCD - TRP Example: TRAS= 4 cycles,              TRCD= 2 cycles. So, TWR &gt;= 2 cycles. TWR must              be programmed to 0x1. If two SDRAM devices are used,              the FMC_SDTR1 and FMC_SDTR2 must be programmed with              the same TWR timing corresponding to the slowest              SDRAM device.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(19,16),Register::ReadWriteAccess,unsigned> twr{}; 
        ///Row precharge delay These bits define              the delay between a Precharge command and another              command in number of memory clock cycles. The TRP              timing is only configured in the FMC_SDTR1 register.              If two SDRAM devices are used, the TRP must be              programmed with the timing of the slowest device.              .... Note: The corresponding bits in the FMC_SDTR2              register are dont care.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(23,20),Register::ReadWriteAccess,unsigned> trp{}; 
        ///Row to column delay These bits define              the delay between the Activate command and a              Read/Write command in number of memory clock cycles.              ....
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(27,24),Register::ReadWriteAccess,unsigned> trcd{}; 
    }
    namespace FmcFmcSdtr2{    ///<This register contains the timing parameters          of each SDRAM bank
        using Addr = Register::Address<0x5200414c,0xf0000000,0x00000000,std::uint32_t>;
        ///Load Mode Register to Active These bits              define the delay between a Load Mode Register command              and an Active or Refresh command in number of memory              clock cycles. ....
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(3,0),Register::ReadWriteAccess,unsigned> tmrd{}; 
        ///Exit Self-refresh delay These bits              define the delay from releasing the Self-refresh              command to issuing the Activate command in number of              memory clock cycles. .... Note: If two SDRAM devices              are used, the FMC_SDTR1 and FMC_SDTR2 must be              programmed with the same TXSR timing corresponding to              the slowest SDRAM device.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(7,4),Register::ReadWriteAccess,unsigned> txsr{}; 
        ///Self refresh time These bits define the              minimum Self-refresh period in number of memory clock              cycles. ....
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(11,8),Register::ReadWriteAccess,unsigned> tras{}; 
        ///Row cycle delay These bits define the              delay between the Refresh command and the Activate              command, as well as the delay between two consecutive              Refresh commands. It is expressed in number of memory              clock cycles. The TRC timing is only configured in              the FMC_SDTR1 register. If two SDRAM devices are              used, the TRC must be programmed with the timings of              the slowest device. .... Note: TRC must match the TRC              and TRFC (Auto Refresh period) timings defined in the              SDRAM device datasheet. Note: The corresponding bits              in the FMC_SDTR2 register are dont              care.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(15,12),Register::ReadWriteAccess,unsigned> trc{}; 
        ///Recovery delay These bits define the              delay between a Write and a Precharge command in              number of memory clock cycles. .... Note: TWR must be              programmed to match the write recovery time (tWR)              defined in the SDRAM datasheet, and to guarantee              that: TWR &#8805; TRAS - TRCD and TWR              &#8805;TRC - TRCD - TRP Example: TRAS= 4 cycles,              TRCD= 2 cycles. So, TWR &gt;= 2 cycles. TWR must              be programmed to 0x1. If two SDRAM devices are used,              the FMC_SDTR1 and FMC_SDTR2 must be programmed with              the same TWR timing corresponding to the slowest              SDRAM device.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(19,16),Register::ReadWriteAccess,unsigned> twr{}; 
        ///Row precharge delay These bits define              the delay between a Precharge command and another              command in number of memory clock cycles. The TRP              timing is only configured in the FMC_SDTR1 register.              If two SDRAM devices are used, the TRP must be              programmed with the timing of the slowest device.              .... Note: The corresponding bits in the FMC_SDTR2              register are dont care.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(23,20),Register::ReadWriteAccess,unsigned> trp{}; 
        ///Row to column delay These bits define              the delay between the Activate command and a              Read/Write command in number of memory clock cycles.              ....
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(27,24),Register::ReadWriteAccess,unsigned> trcd{}; 
    }
    namespace FmcFmcSdcmr{    ///<This register contains the command issued          when the SDRAM device is accessed. This register is used          to initialize the SDRAM device, and to activate the          Self-refresh and the Power-down modes. As soon as the          MODE field is written, the command will be issued only to          one or to both SDRAM banks according to CTB1 and CTB2          command bits. This register is the same for both SDRAM          banks.
        using Addr = Register::Address<0x52004150,0xff800000,0x00000000,std::uint32_t>;
        ///Command mode These bits define the              command issued to the SDRAM device. Note: When a              command is issued, at least one Command Target Bank              bit ( CTB1 or CTB2) must be set otherwise the command              will be ignored. Note: If two SDRAM banks are used,              the Auto-refresh and PALL command must be issued              simultaneously to the two devices with CTB1 and CTB2              bits set otherwise the command will be ignored. Note:              If only one SDRAM bank is used and a command is              issued with its associated CTB bit set, the other CTB              bit of the unused bank must be kept to              0.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(2,0),Register::ReadWriteAccess,unsigned> mode{}; 
        ///Command Target Bank 2 This bit indicates              whether the command will be issued to SDRAM Bank 2 or              not.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(3,3),Register::ReadWriteAccess,unsigned> ctb2{}; 
        ///Command Target Bank 1 This bit indicates              whether the command will be issued to SDRAM Bank 1 or              not.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(4,4),Register::ReadWriteAccess,unsigned> ctb1{}; 
        ///Number of Auto-refresh These bits define              the number of consecutive Auto-refresh commands              issued when MODE = 011. ....
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(8,5),Register::ReadWriteAccess,unsigned> nrfs{}; 
        ///Mode Register definition This 14-bit              field defines the SDRAM Mode Register content. The              Mode Register is programmed using the Load Mode              Register command. The MRD[13:0] bits are also used to              program the extended mode register for mobile              SDRAM.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(22,9),Register::ReadWriteAccess,unsigned> mrd{}; 
    }
    namespace FmcFmcSdrtr{    ///<This register sets the refresh rate in          number of SDCLK clock cycles between the refresh cycles          by configuring the Refresh Timer Count value.Examplewhere          64 ms is the SDRAM refresh period.The refresh rate must          be increased by 20 SDRAM clock cycles (as in the above          example) to obtain a safe margin if an internal refresh          request occurs when a read request has been accepted. It          corresponds to a COUNT value of 0000111000000 (448). This          13-bit field is loaded into a timer which is decremented          using the SDRAM clock. This timer generates a refresh          pulse when zero is reached. The COUNT value must be set          at least to 41 SDRAM clock cycles.As soon as the          FMC_SDRTR register is programmed, the timer starts          counting. If the value programmed in the register is 0,          no refresh is carried out. This register must not be          reprogrammed after the initialization procedure to avoid          modifying the refresh rate.Each time a refresh pulse is          generated, this 13-bit COUNT field is reloaded into the          counter.If a memory access is in progress, the          Auto-refresh request is delayed. However, if the memory          access and Auto-refresh requests are generated          simultaneously, the Auto-refresh takes precedence. If the          memory access occurs during a refresh operation, the          request is buffered to be processed when the refresh is          complete.This register is common to SDRAM bank 1 and bank          2.
        using Addr = Register::Address<0x52004154,0xffff8000,0x00000000,std::uint32_t>;
        ///Clear Refresh error flag This bit is              used to clear the Refresh Error Flag (RE) in the              Status Register.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(0,0),Register::Access<Register::AccessType::writeOnly,Register::ReadActionType::normal,Register::ModifiedWriteValueType::normal>,unsigned> cre{}; 
        ///Refresh Timer Count This 13-bit field              defines the refresh rate of the SDRAM device. It is              expressed in number of memory clock cycles. It must              be set at least to 41 SDRAM clock cycles (0x29).              Refresh rate = (COUNT + 1) x SDRAM frequency clock              COUNT = (SDRAM refresh period / Number of rows) -              20
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(13,1),Register::ReadWriteAccess,unsigned> count{}; 
        ///RES Interrupt Enable
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(14,14),Register::ReadWriteAccess,unsigned> reie{}; 
    }
    namespace FmcFmcSdsr{    ///<SDRAM Status register
        using Addr = Register::Address<0x52004158,0xffffffe0,0x00000000,std::uint32_t>;
        ///Refresh error flag An interrupt is              generated if REIE = 1 and RE = 1
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(0,0),Register::ReadWriteAccess,unsigned> re{}; 
        ///Status Mode for Bank 1 These bits define              the Status Mode of SDRAM Bank 1.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(2,1),Register::ReadWriteAccess,unsigned> modes1{}; 
        ///Status Mode for Bank 2 These bits define              the Status Mode of SDRAM Bank 2.
        constexpr Register::FieldLocation<Addr,Register::maskFromRange(4,3),Register::ReadWriteAccess,unsigned> modes2{}; 
    }
}
